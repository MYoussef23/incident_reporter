# --------------- Queries --------------- #

incident_details_query: |
  SecurityIncident
    | where IncidentNumber == '{incident_no}'
    | mv-expand AlertIds
    | extend AlertIdStr = tostring(AlertIds)
    | project IncidentNumber, AlertIdStr, Title
    | join kind=inner (
        SecurityAlert
        | project ProductName, SystemAlertId, ExtendedProperties, Tactics, Techniques
    ) on $left.AlertIdStr == $right.SystemAlertId
    | extend 
        QueryStartTimeUTC = parse_json(ExtendedProperties)["Query Start Time UTC"], 
        QueryEndTimeUTC = parse_json(ExtendedProperties)["Query End Time UTC"], 
        Query = parse_json(ExtendedProperties)["Query"]
    | summarize
        AlertIds = make_set(AlertIdStr),
        Titles = make_set(Title),
        StartTimes = make_set(QueryStartTimeUTC), 
        EndTimes = make_set(QueryEndTimeUTC), 
        Queries = make_set(Query)
        by ProductName, AlertIdStr, Tactics, Techniques
    // Expand each set so you get one row per alert within the incident
    | mv-expand AlertIds, Titles, StartTimes, EndTimes, Queries
    | project Titles, ProductName, AlertIds, StartTimes, EndTimes, Queries, Tactics, Techniques

get_alert_link_query: |
  SecurityAlert
    | summarize arg_max(TimeGenerated, *) by SystemAlertId
    | where SystemAlertId in('{alert_id}')
    | project AlertLink

IDENTITYINFO_KQL: |
  let UserInput = "{AccountUPN}";
  IdentityInfo
  | extend UserPrincipalName = AccountUPN
  | extend UserDisplayName = AccountDisplayName
  | where UserPrincipalName contains UserInput
  | summarize LatestTimeGenerated = max(TimeGenerated) by UserDisplayName, UserPrincipalName, IsAccountEnabled, MailAddress, Manager, Department, JobTitle, AccountCreationTime, SAMAccountName
  | sort by LatestTimeGenerated 

SIGNIN_INTERACTIVE_KQL: |
  let UserPrincipalName_ = "{UserPrincipalName}";
  SigninLogs
  | where UserPrincipalName =~ UserPrincipalName_
  | extend DeviceBrowser = tostring(DeviceDetail.browser)
  | extend DeviceId = tostring(DeviceDetail.deviceId)
  | extend DeviceDisplayName = parse_json(DeviceDetail).displayName
  | extend DeviceOperatingSystem = parse_json(DeviceDetail).operatingSystem
  | extend DeviceTrustType = tostring(DeviceDetail.trustType)
  | extend DeviceIsManaged = tostring(DeviceDetail.isManaged)
  | extend City = tostring(LocationDetails.city)
  | extend CountryOrRegion = tostring(LocationDetails.countryOrRegion)
  | extend State = tostring(LocationDetails.state)
  | extend StatusAdditionalDetails = tostring(Status.additionalDetails)
  | extend StatusFailureReason = tostring(Status.failureReason)
  | project TimeGenerated,ResultType,StatusFailureReason,DeviceDisplayName,DeviceOperatingSystem,DeviceBrowser,Location,City,State,AppDisplayName,IPAddress
  | sort by TimeGenerated desc

SIGNIN_NONINTERACTIVE_KQL: |
  let UserPrincipalName_ = "{UserPrincipalName}";
  AADNonInteractiveUserSignInLogs
  | where UserPrincipalName =~ UserPrincipalName_
  | extend DeviceBrowser = parse_json(DeviceDetail).browser
  | extend DeviceDisplayName = parse_json(DeviceDetail).displayName
  | extend DeviceOperatingSystem = parse_json(DeviceDetail).operatingSystem
  | extend City = parse_json(LocationDetails).city
  | extend CountryOrRegion = parse_json(LocationDetails).countryOrRegion
  | extend State = parse_json(LocationDetails).state
  | extend StatusAdditionalDetails = parse_json(Status).additionalDetails
  | extend StatusFailureReason = parse_json(Status).failureReason
  | project TimeGenerated,ResultType,StatusFailureReason,DeviceDisplayName,DeviceOperatingSystem,DeviceBrowser,Location,City,State,AppDisplayName,IPAddress
  | sort by TimeGenerated desc

OFFICE_ACTIVITY_KQL: |
  let UPN = "{UserPrincipalName}";
  let Operation_ = "{Operation}";
  OfficeActivity
  | where UserId =~ UPN
  | where array_length(Ops) == 0 or Operation in (Ops)
  | project TimeGenerated, UserAgent, Operation, OfficeWorkload, ClientIP, Site_Url, SourceRelativeUrl, SourceFileName
  | sort by TimeGenerated desc

# --------------- LLM Prompts --------------- #

PROMPT_TEMPLATE_FOR_MITRE_ATTACK_TECHNIQUES: |
  You are a cybersecurity reasoning assistant that maps alerts to MITRE ATT&CK techniques (version 17.1).

  Task
  Given:
  - Alert Title
  - Detection Query (KQL/SPL/XQL/etc.)
  - Event Data Snippet, if provided (a small excerpt of actual matched results)

  Produce a STRICT JSON array describing the top matching ATT&CK techniques. Each element must have:
  - "technique_id" — a valid ATT&CK Technique or Sub-technique ID, formatted T#### or T####.### from MITRE ATT&CK v17.1.
  - "reason" — a concise explanation (<= 25 words) linking the alert to the technique using evidence from the query/snippet.

  Hard Rules
  1. Output ONLY JSON — no prose, no markdown fences, no headings, no comments.
  2. JSON must be a single array [...]. No wrapper keys.
  3. Include only the two fields per object: technique_id, reason. No extra fields.
  4. Use v17.1 technique IDs only. Prefer sub-techniques when the query/snippet clearly indicates them.
  5. Base mappings on observable signals in the query/snippet (e.g., processes, commands, API calls, cloud actions, auth artifacts). No speculation.
  6. If evidence is insufficient, return an empty array [].
  7. Return at most 3 techniques, ordered by strongest evidence first.
  8. The reason must reference concrete indicators (e.g., command/path/event/provider/operation), not generic statements.

  Evidence Examples (non-exhaustive)
  - Process/command lines (cmd.exe /c, powershell -enc, /bin/sh, reg add, schtasks, bitsadmin, curl, wmic, vssadmin, rundll32)
  - File/registry/service/scheduled task changes
  - Cloud actions (IAM role changes, key creation/use, bucket policies, MFA disablement)
  - Auth/sign-in anomalies, token operations, OAuth/grant changes
  - Network beacons, C2 patterns, exfil destinations, data staging paths

  Validation
  - Technique ID must match regex: ^T\d{4}(?:\.\d{3})?$
  - Max 3 objects, each with exactly 2 keys: technique_id, reason.
  - If multiple plausible techniques exist, choose those best supported by explicit artifacts.

  example of the expected output (for model's output validation; follow exactly):

  example output positive:
  [
    {
      "technique_id": "<technique_id>",
      "reason": "<explanation>"
    },
    {
      "technique_id": "<technique_id>",
      "reason": "<explanation>"
    }
  ]

  example output negative:
    []
  

  User Prompt Template
  Alert Title:
  {alert_title}

  {events_query}

  Return only the JSON array as specified.

example_output_positive: |
  [
    {
      "technique_id": "T1059.001",
      "reason": "Suspicious PowerShell command with -enc flag indicates potential execution of obfuscated code."
    },
    {
      "technique_id": "T1059",
      "reason": "Detection query identifies script interpreter execution consistent with command-line interface usage."
    }
  ]

example_output_negative: |
  []


